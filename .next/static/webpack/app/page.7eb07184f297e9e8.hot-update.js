"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./hooks/useShoppingList.ts":
/*!**********************************!*\
  !*** ./hooks/useShoppingList.ts ***!
  \**********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ useShoppingList)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lib_search__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/search */ \"(app-pages-browser)/./lib/search.ts\");\n\n\n// **FIX:** Separated 'Produce' into 'Fruits' and 'Vegetables'\nconst categories = {\n    // Fruits\n    apple: \"Fruits\",\n    banana: \"Fruits\",\n    orange: \"Fruits\",\n    grapes: \"Fruits\",\n    mango: \"Fruits\",\n    watermelon: \"Fruits\",\n    strawberries: \"Fruits\",\n    cherries: \"Fruits\",\n    pineapple: \"Fruits\",\n    // Vegetables\n    potato: \"Vegetables\",\n    onion: \"Vegetables\",\n    tomato: \"Vegetables\",\n    carrot: \"Vegetables\",\n    spinach: \"Vegetables\",\n    broccoli: \"Vegetables\",\n    cucumber: \"Vegetables\",\n    // Dairy & Alternatives\n    milk: \"Dairy\",\n    cheese: \"Dairy\",\n    butter: \"Dairy\",\n    yogurt: \"Dairy\",\n    // Snacks\n    chips: \"Snacks\",\n    cookies: \"Snacks\",\n    nuts: \"Snacks\",\n    // Bakery\n    bread: \"Bakery\",\n    cake: \"Bakery\",\n    muffins: \"Bakery\",\n    // Grains & Pantry\n    rice: \"Grains\",\n    pasta: \"Grains\",\n    flour: \"Grains\",\n    sugar: \"Pantry\",\n    salt: \"Pantry\",\n    oil: \"Pantry\",\n    ketchup: \"Pantry\",\n    honey: \"Pantry\",\n    // Household & Personal Care\n    soap: \"Household\",\n    toothpaste: \"Personal Care\",\n    shampoo: \"Personal Care\"\n};\nconst numberWords = {\n    one: 1,\n    two: 2,\n    three: 3,\n    four: 4,\n    five: 5,\n    six: 6,\n    seven: 7,\n    eight: 8,\n    nine: 9,\n    ten: 10\n};\nfunction parseItem(command) {\n    const cleanedCommand = command.toLowerCase().trim();\n    const words = cleanedCommand.split(' ');\n    const firstWord = words[0];\n    if (numberWords[firstWord]) {\n        return {\n            quantity: numberWords[firstWord],\n            name: words.slice(1).join(' ')\n        };\n    }\n    const digitMatch = cleanedCommand.match(/^(\\d+)\\s*(.*)/);\n    if (digitMatch) {\n        return {\n            quantity: parseInt(digitMatch[1], 10),\n            name: digitMatch[2].trim()\n        };\n    }\n    return {\n        quantity: 1,\n        name: cleanedCommand\n    };\n}\nfunction useShoppingList() {\n    const [items, setItems] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useShoppingList.useEffect\": ()=>{\n            try {\n                const savedItemsJSON = localStorage.getItem(\"shoppingItems\");\n                if (savedItemsJSON) {\n                    const savedItems = JSON.parse(savedItemsJSON);\n                    const migratedItems = savedItems.map({\n                        \"useShoppingList.useEffect.migratedItems\": (item)=>{\n                            if (typeof item.price !== 'number') {\n                                console.log(\"Migrating old item: \".concat(item.name));\n                                return {\n                                    ...item,\n                                    price: (0,_lib_search__WEBPACK_IMPORTED_MODULE_1__.getItemPrice)(item.name)\n                                };\n                            }\n                            return item;\n                        }\n                    }[\"useShoppingList.useEffect.migratedItems\"]);\n                    setItems(migratedItems);\n                }\n            } catch (error) {\n                console.error(\"Failed to parse/migrate shopping items from localStorage:\", error);\n                localStorage.removeItem(\"shoppingItems\");\n            }\n        }\n    }[\"useShoppingList.useEffect\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useShoppingList.useEffect\": ()=>{\n            localStorage.setItem(\"shoppingItems\", JSON.stringify(items));\n        }\n    }[\"useShoppingList.useEffect\"], [\n        items\n    ]);\n    const addItem = (command)=>{\n        const { quantity, name } = parseItem(command);\n        if (!name) return;\n        const existingItem = items.find((i)=>i.name.toLowerCase() === name.toLowerCase());\n        if (existingItem) {\n            increaseQuantity(existingItem.id, quantity);\n        } else {\n            const categoryKey = Object.keys(categories).find((key)=>name.includes(key)) || \"other\";\n            const price = (0,_lib_search__WEBPACK_IMPORTED_MODULE_1__.getItemPrice)(name);\n            const newItem = {\n                id: Date.now().toString(),\n                name,\n                quantity,\n                category: categories[categoryKey] || \"Other\",\n                price,\n                addedAt: new Date(),\n                completed: false\n            };\n            setItems((prev)=>[\n                    ...prev,\n                    newItem\n                ]);\n        }\n    };\n    const removeItemByName = (name)=>{\n        if (!name) return false;\n        const itemExists = items.some((i)=>i.name.toLowerCase() === name.toLowerCase());\n        if (itemExists) {\n            setItems((prev)=>prev.filter((i)=>i.name.toLowerCase() !== name.toLowerCase()));\n        }\n        return itemExists;\n    };\n    const increaseQuantity = function(id) {\n        let amount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;\n        setItems(items.map((item)=>item.id === id ? {\n                ...item,\n                quantity: item.quantity + amount\n            } : item));\n    };\n    const decreaseQuantity = function(id) {\n        let amount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;\n        setItems(items.map((item)=>item.id === id ? {\n                ...item,\n                quantity: Math.max(1, item.quantity - amount)\n            } : item));\n    };\n    const toggleItem = (id)=>{\n        setItems((prev)=>prev.map((i)=>i.id === id ? {\n                    ...i,\n                    completed: !i.completed\n                } : i));\n    };\n    const clearList = ()=>setItems([]);\n    const groupedItems = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"useShoppingList.useMemo[groupedItems]\": ()=>items.reduce({\n                \"useShoppingList.useMemo[groupedItems]\": (groups, item)=>{\n                    const category = item.category || \"Other\";\n                    if (!groups[category]) groups[category] = [];\n                    groups[category].push(item);\n                    return groups;\n                }\n            }[\"useShoppingList.useMemo[groupedItems]\"], {})\n    }[\"useShoppingList.useMemo[groupedItems]\"], [\n        items\n    ]);\n    const totalCost = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"useShoppingList.useMemo[totalCost]\": ()=>items.reduce({\n                \"useShoppingList.useMemo[totalCost]\": (total, item)=>total + (item.price || 0) * item.quantity\n            }[\"useShoppingList.useMemo[totalCost]\"], 0)\n    }[\"useShoppingList.useMemo[totalCost]\"], [\n        items\n    ]);\n    return {\n        items,\n        addItem,\n        removeItemByName,\n        increaseQuantity,\n        decreaseQuantity,\n        toggleItem,\n        clearList,\n        groupedItems,\n        totalCost\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZVNob3BwaW5nTGlzdC50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXFEO0FBQ1I7QUFZN0MsOERBQThEO0FBQzlELE1BQU1JLGFBQXFDO0lBQ3pDLFNBQVM7SUFDVEMsT0FBTztJQUFVQyxRQUFRO0lBQVVDLFFBQVE7SUFBVUMsUUFBUTtJQUFVQyxPQUFPO0lBQVVDLFlBQVk7SUFBVUMsY0FBYztJQUFVQyxVQUFVO0lBQVVDLFdBQVc7SUFFckssYUFBYTtJQUNiQyxRQUFRO0lBQWNDLE9BQU87SUFBY0MsUUFBUTtJQUFjQyxRQUFRO0lBQWNDLFNBQVM7SUFBY0MsVUFBVTtJQUFjQyxVQUFVO0lBRWhKLHVCQUF1QjtJQUN2QkMsTUFBTTtJQUFTQyxRQUFRO0lBQVNDLFFBQVE7SUFBU0MsUUFBUTtJQUV6RCxTQUFTO0lBQ1RDLE9BQU87SUFBVUMsU0FBUztJQUFVQyxNQUFNO0lBRTFDLFNBQVM7SUFDVEMsT0FBTztJQUFVQyxNQUFNO0lBQVVDLFNBQVM7SUFFMUMsa0JBQWtCO0lBQ2xCQyxNQUFNO0lBQVVDLE9BQU87SUFBVUMsT0FBTztJQUN4Q0MsT0FBTztJQUFVQyxNQUFNO0lBQVVDLEtBQUs7SUFBVUMsU0FBUztJQUFVQyxPQUFPO0lBRTFFLDRCQUE0QjtJQUM1QkMsTUFBTTtJQUNOQyxZQUFZO0lBQWlCQyxTQUFTO0FBQ3hDO0FBRUEsTUFBTUMsY0FBc0M7SUFDMUNDLEtBQUs7SUFBR0MsS0FBSztJQUFHQyxPQUFPO0lBQUdDLE1BQU07SUFBR0MsTUFBTTtJQUN6Q0MsS0FBSztJQUFHQyxPQUFPO0lBQUdDLE9BQU87SUFBR0MsTUFBTTtJQUFHQyxLQUFLO0FBQzVDO0FBRUEsU0FBU0MsVUFBVUMsT0FBZTtJQUNoQyxNQUFNQyxpQkFBaUJELFFBQVFFLFdBQVcsR0FBR0MsSUFBSTtJQUNqRCxNQUFNQyxRQUFRSCxlQUFlSSxLQUFLLENBQUM7SUFDbkMsTUFBTUMsWUFBWUYsS0FBSyxDQUFDLEVBQUU7SUFF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QUMsQ0FBQ0ksT0FBTzFDLE9BQVMwQyxRQUFRLENBQUMxQyxLQUFLQyxLQUFLLElBQUksS0FBS0QsS0FBS2xCLFFBQVE7cURBQUU7NkNBQzNFO1FBQUNRO0tBQU07SUFFUCxPQUFPO1FBQUVBO1FBQU9rQjtRQUFTbUI7UUFBa0JmO1FBQWtCb0I7UUFBa0JHO1FBQVlDO1FBQVdDO1FBQWNJO0lBQVU7QUFDaEkiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xca2FuYW5cXE9uZURyaXZlXFxEZXNrdG9wXFxWb2ljZS1Db21tYW5kLVNob3BwaW5nLUFzc2lzdGFudFxcaG9va3NcXHVzZVNob3BwaW5nTGlzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VNZW1vIH0gZnJvbSBcInJlYWN0XCI7XHJcbmltcG9ydCB7IGdldEl0ZW1QcmljZSB9IGZyb20gXCIuLi9saWIvc2VhcmNoXCI7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFNob3BwaW5nSXRlbSB7XHJcbiAgaWQ6IHN0cmluZztcclxuICBuYW1lOiBzdHJpbmc7XHJcbiAgcXVhbnRpdHk6IG51bWJlcjtcclxuICBjYXRlZ29yeTogc3RyaW5nO1xyXG4gIHByaWNlOiBudW1iZXI7XHJcbiAgYWRkZWRBdDogRGF0ZTtcclxuICBjb21wbGV0ZWQ6IGJvb2xlYW47XHJcbn1cclxuXHJcbi8vICoqRklYOioqIFNlcGFyYXRlZCAnUHJvZHVjZScgaW50byAnRnJ1aXRzJyBhbmQgJ1ZlZ2V0YWJsZXMnXHJcbmNvbnN0IGNhdGVnb3JpZXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XHJcbiAgLy8gRnJ1aXRzXHJcbiAgYXBwbGU6IFwiRnJ1aXRzXCIsIGJhbmFuYTogXCJGcnVpdHNcIiwgb3JhbmdlOiBcIkZydWl0c1wiLCBncmFwZXM6IFwiRnJ1aXRzXCIsIG1hbmdvOiBcIkZydWl0c1wiLCB3YXRlcm1lbG9uOiBcIkZydWl0c1wiLCBzdHJhd2JlcnJpZXM6IFwiRnJ1aXRzXCIsIGNoZXJyaWVzOiBcIkZydWl0c1wiLCBwaW5lYXBwbGU6IFwiRnJ1aXRzXCIsXHJcblxyXG4gIC8vIFZlZ2V0YWJsZXNcclxuICBwb3RhdG86IFwiVmVnZXRhYmxlc1wiLCBvbmlvbjogXCJWZWdldGFibGVzXCIsIHRvbWF0bzogXCJWZWdldGFibGVzXCIsIGNhcnJvdDogXCJWZWdldGFibGVzXCIsIHNwaW5hY2g6IFwiVmVnZXRhYmxlc1wiLCBicm9jY29saTogXCJWZWdldGFibGVzXCIsIGN1Y3VtYmVyOiBcIlZlZ2V0YWJsZXNcIixcclxuICBcclxuICAvLyBEYWlyeSAmIEFsdGVybmF0aXZlc1xyXG4gIG1pbGs6IFwiRGFpcnlcIiwgY2hlZXNlOiBcIkRhaXJ5XCIsIGJ1dHRlcjogXCJEYWlyeVwiLCB5b2d1cnQ6IFwiRGFpcnlcIixcclxuICBcclxuICAvLyBTbmFja3NcclxuICBjaGlwczogXCJTbmFja3NcIiwgY29va2llczogXCJTbmFja3NcIiwgbnV0czogXCJTbmFja3NcIixcclxuICBcclxuICAvLyBCYWtlcnlcclxuICBicmVhZDogXCJCYWtlcnlcIiwgY2FrZTogXCJCYWtlcnlcIiwgbXVmZmluczogXCJCYWtlcnlcIixcclxuICBcclxuICAvLyBHcmFpbnMgJiBQYW50cnlcclxuICByaWNlOiBcIkdyYWluc1wiLCBwYXN0YTogXCJHcmFpbnNcIiwgZmxvdXI6IFwiR3JhaW5zXCIsXHJcbiAgc3VnYXI6IFwiUGFudHJ5XCIsIHNhbHQ6IFwiUGFudHJ5XCIsIG9pbDogXCJQYW50cnlcIiwga2V0Y2h1cDogXCJQYW50cnlcIiwgaG9uZXk6IFwiUGFudHJ5XCIsXHJcbiAgXHJcbiAgLy8gSG91c2Vob2xkICYgUGVyc29uYWwgQ2FyZVxyXG4gIHNvYXA6IFwiSG91c2Vob2xkXCIsXHJcbiAgdG9vdGhwYXN0ZTogXCJQZXJzb25hbCBDYXJlXCIsIHNoYW1wb286IFwiUGVyc29uYWwgQ2FyZVwiLFxyXG59O1xyXG5cclxuY29uc3QgbnVtYmVyV29yZHM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7XHJcbiAgb25lOiAxLCB0d286IDIsIHRocmVlOiAzLCBmb3VyOiA0LCBmaXZlOiA1LFxyXG4gIHNpeDogNiwgc2V2ZW46IDcsIGVpZ2h0OiA4LCBuaW5lOiA5LCB0ZW46IDEwLFxyXG59O1xyXG5cclxuZnVuY3Rpb24gcGFyc2VJdGVtKGNvbW1hbmQ6IHN0cmluZyk6IHsgcXVhbnRpdHk6IG51bWJlcjsgbmFtZTogc3RyaW5nIH0ge1xyXG4gIGNvbnN0IGNsZWFuZWRDb21tYW5kID0gY29tbWFuZC50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcclxuICBjb25zdCB3b3JkcyA9IGNsZWFuZWRDb21tYW5kLnNwbGl0KCcgJyk7XHJcbiAgY29uc3QgZmlyc3RXb3JkID0gd29yZHNbMF07XHJcblxyXG4gIGlmIChudW1iZXJXb3Jkc1tmaXJzdFdvcmRdKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBxdWFudGl0eTogbnVtYmVyV29yZHNbZmlyc3RXb3JkXSxcclxuICAgICAgbmFtZTogd29yZHMuc2xpY2UoMSkuam9pbignICcpLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGNvbnN0IGRpZ2l0TWF0Y2ggPSBjbGVhbmVkQ29tbWFuZC5tYXRjaCgvXihcXGQrKVxccyooLiopLyk7XHJcbiAgaWYgKGRpZ2l0TWF0Y2gpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHF1YW50aXR5OiBwYXJzZUludChkaWdpdE1hdGNoWzFdLCAxMCksXHJcbiAgICAgIG5hbWU6IGRpZ2l0TWF0Y2hbMl0udHJpbSgpLFxyXG4gICAgfTtcclxuICB9XHJcbiAgXHJcbiAgcmV0dXJuIHsgcXVhbnRpdHk6IDEsIG5hbWU6IGNsZWFuZWRDb21tYW5kIH07XHJcbn1cclxuXHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1c2VTaG9wcGluZ0xpc3QoKSB7XHJcbiAgY29uc3QgW2l0ZW1zLCBzZXRJdGVtc10gPSB1c2VTdGF0ZTxTaG9wcGluZ0l0ZW1bXT4oW10pO1xyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3Qgc2F2ZWRJdGVtc0pTT04gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInNob3BwaW5nSXRlbXNcIik7XHJcbiAgICAgIGlmIChzYXZlZEl0ZW1zSlNPTikge1xyXG4gICAgICAgIGNvbnN0IHNhdmVkSXRlbXMgPSBKU09OLnBhcnNlKHNhdmVkSXRlbXNKU09OKTtcclxuICAgICAgICBcclxuICAgICAgICBjb25zdCBtaWdyYXRlZEl0ZW1zID0gc2F2ZWRJdGVtcy5tYXAoKGl0ZW06IGFueSkgPT4ge1xyXG4gICAgICAgICAgaWYgKHR5cGVvZiBpdGVtLnByaWNlICE9PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgTWlncmF0aW5nIG9sZCBpdGVtOiAke2l0ZW0ubmFtZX1gKTtcclxuICAgICAgICAgICAgcmV0dXJuIHsgLi4uaXRlbSwgcHJpY2U6IGdldEl0ZW1QcmljZShpdGVtLm5hbWUpIH07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gaXRlbTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICBzZXRJdGVtcyhtaWdyYXRlZEl0ZW1zKTtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBwYXJzZS9taWdyYXRlIHNob3BwaW5nIGl0ZW1zIGZyb20gbG9jYWxTdG9yYWdlOlwiLCBlcnJvcik7XHJcbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKFwic2hvcHBpbmdJdGVtc1wiKTtcclxuICAgIH1cclxuICB9LCBbXSk7XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcInNob3BwaW5nSXRlbXNcIiwgSlNPTi5zdHJpbmdpZnkoaXRlbXMpKTtcclxuICB9LCBbaXRlbXNdKTtcclxuXHJcbiAgY29uc3QgYWRkSXRlbSA9IChjb21tYW5kOiBzdHJpbmcpID0+IHtcclxuICAgIGNvbnN0IHsgcXVhbnRpdHksIG5hbWUgfSA9IHBhcnNlSXRlbShjb21tYW5kKTtcclxuICAgIGlmICghbmFtZSkgcmV0dXJuO1xyXG5cclxuICAgIGNvbnN0IGV4aXN0aW5nSXRlbSA9IGl0ZW1zLmZpbmQoaSA9PiBpLm5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZS50b0xvd2VyQ2FzZSgpKTtcclxuXHJcbiAgICBpZiAoZXhpc3RpbmdJdGVtKSB7XHJcbiAgICAgICAgaW5jcmVhc2VRdWFudGl0eShleGlzdGluZ0l0ZW0uaWQsIHF1YW50aXR5KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc3QgY2F0ZWdvcnlLZXkgPSBPYmplY3Qua2V5cyhjYXRlZ29yaWVzKS5maW5kKChrZXkpID0+IG5hbWUuaW5jbHVkZXMoa2V5KSkgfHwgXCJvdGhlclwiO1xyXG4gICAgICAgIGNvbnN0IHByaWNlID0gZ2V0SXRlbVByaWNlKG5hbWUpO1xyXG5cclxuICAgICAgICBjb25zdCBuZXdJdGVtOiBTaG9wcGluZ0l0ZW0gPSB7XHJcbiAgICAgICAgICAgIGlkOiBEYXRlLm5vdygpLnRvU3RyaW5nKCksXHJcbiAgICAgICAgICAgIG5hbWUsXHJcbiAgICAgICAgICAgIHF1YW50aXR5LFxyXG4gICAgICAgICAgICBjYXRlZ29yeTogY2F0ZWdvcmllc1tjYXRlZ29yeUtleV0gfHwgXCJPdGhlclwiLFxyXG4gICAgICAgICAgICBwcmljZSxcclxuICAgICAgICAgICAgYWRkZWRBdDogbmV3IERhdGUoKSxcclxuICAgICAgICAgICAgY29tcGxldGVkOiBmYWxzZSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHNldEl0ZW1zKChwcmV2KSA9PiBbLi4ucHJldiwgbmV3SXRlbV0pO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGNvbnN0IHJlbW92ZUl0ZW1CeU5hbWUgPSAobmFtZTogc3RyaW5nKTogYm9vbGVhbiA9PiB7XHJcbiAgICBpZiAoIW5hbWUpIHJldHVybiBmYWxzZTtcclxuICAgIGNvbnN0IGl0ZW1FeGlzdHMgPSBpdGVtcy5zb21lKGkgPT4gaS5uYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUudG9Mb3dlckNhc2UoKSk7XHJcbiAgICBpZiAoaXRlbUV4aXN0cykge1xyXG4gICAgICBzZXRJdGVtcygocHJldikgPT4gcHJldi5maWx0ZXIoKGkpID0+IGkubmFtZS50b0xvd2VyQ2FzZSgpICE9PSBuYW1lLnRvTG93ZXJDYXNlKCkpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBpdGVtRXhpc3RzO1xyXG4gIH07XHJcbiAgXHJcbiAgY29uc3QgaW5jcmVhc2VRdWFudGl0eSA9IChpZDogc3RyaW5nLCBhbW91bnQgPSAxKSA9PiB7XHJcbiAgICBzZXRJdGVtcyhpdGVtcy5tYXAoaXRlbSA9PiBpdGVtLmlkID09PSBpZCA/IHsgLi4uaXRlbSwgcXVhbnRpdHk6IGl0ZW0ucXVhbnRpdHkgKyBhbW91bnQgfSA6IGl0ZW0pKTtcclxuICB9O1xyXG5cclxuICBjb25zdCBkZWNyZWFzZVF1YW50aXR5ID0gKGlkOiBzdHJpbmcsIGFtb3VudCA9IDEpID0+IHtcclxuICAgIHNldEl0ZW1zKGl0ZW1zLm1hcChpdGVtID0+IFxyXG4gICAgICAgIGl0ZW0uaWQgPT09IGlkIFxyXG4gICAgICAgID8geyAuLi5pdGVtLCBxdWFudGl0eTogTWF0aC5tYXgoMSwgaXRlbS5xdWFudGl0eSAtIGFtb3VudCkgfSBcclxuICAgICAgICA6IGl0ZW1cclxuICAgICkpO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IHRvZ2dsZUl0ZW0gPSAoaWQ6IHN0cmluZykgPT4ge1xyXG4gICAgc2V0SXRlbXMoKHByZXYpID0+IHByZXYubWFwKChpKSA9PiAoaS5pZCA9PT0gaWQgPyB7IC4uLmksIGNvbXBsZXRlZDogIWkuY29tcGxldGVkIH0gOiBpKSkpO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IGNsZWFyTGlzdCA9ICgpID0+IHNldEl0ZW1zKFtdKTtcclxuXHJcbiAgY29uc3QgZ3JvdXBlZEl0ZW1zID0gdXNlTWVtbygoKSA9PiBpdGVtcy5yZWR1Y2UoXHJcbiAgICAoZ3JvdXBzLCBpdGVtKSA9PiB7XHJcbiAgICAgIGNvbnN0IGNhdGVnb3J5ID0gaXRlbS5jYXRlZ29yeSB8fCBcIk90aGVyXCI7XHJcbiAgICAgIGlmICghZ3JvdXBzW2NhdGVnb3J5XSkgZ3JvdXBzW2NhdGVnb3J5XSA9IFtdO1xyXG4gICAgICBncm91cHNbY2F0ZWdvcnldLnB1c2goaXRlbSk7XHJcbiAgICAgIHJldHVybiBncm91cHM7XHJcbiAgICB9LFxyXG4gICAge30gYXMgUmVjb3JkPHN0cmluZywgU2hvcHBpbmdJdGVtW10+XHJcbiAgKSwgW2l0ZW1zXSk7XHJcbiAgXHJcbiAgY29uc3QgdG90YWxDb3N0ID0gdXNlTWVtbygoKSA9PiBcclxuICAgIGl0ZW1zLnJlZHVjZSgodG90YWwsIGl0ZW0pID0+IHRvdGFsICsgKGl0ZW0ucHJpY2UgfHwgMCkgKiBpdGVtLnF1YW50aXR5LCAwKSxcclxuICBbaXRlbXNdKTtcclxuXHJcbiAgcmV0dXJuIHsgaXRlbXMsIGFkZEl0ZW0sIHJlbW92ZUl0ZW1CeU5hbWUsIGluY3JlYXNlUXVhbnRpdHksIGRlY3JlYXNlUXVhbnRpdHksIHRvZ2dsZUl0ZW0sIGNsZWFyTGlzdCwgZ3JvdXBlZEl0ZW1zLCB0b3RhbENvc3QgfTtcclxufSJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInVzZU1lbW8iLCJnZXRJdGVtUHJpY2UiLCJjYXRlZ29yaWVzIiwiYXBwbGUiLCJiYW5hbmEiLCJvcmFuZ2UiLCJncmFwZXMiLCJtYW5nbyIsIndhdGVybWVsb24iLCJzdHJhd2JlcnJpZXMiLCJjaGVycmllcyIsInBpbmVhcHBsZSIsInBvdGF0byIsIm9uaW9uIiwidG9tYXRvIiwiY2Fycm90Iiwic3BpbmFjaCIsImJyb2Njb2xpIiwiY3VjdW1iZXIiLCJtaWxrIiwiY2hlZXNlIiwiYnV0dGVyIiwieW9ndXJ0IiwiY2hpcHMiLCJjb29raWVzIiwibnV0cyIsImJyZWFkIiwiY2FrZSIsIm11ZmZpbnMiLCJyaWNlIiwicGFzdGEiLCJmbG91ciIsInN1Z2FyIiwic2FsdCIsIm9pbCIsImtldGNodXAiLCJob25leSIsInNvYXAiLCJ0b290aHBhc3RlIiwic2hhbXBvbyIsIm51bWJlcldvcmRzIiwib25lIiwidHdvIiwidGhyZWUiLCJmb3VyIiwiZml2ZSIsInNpeCIsInNldmVuIiwiZWlnaHQiLCJuaW5lIiwidGVuIiwicGFyc2VJdGVtIiwiY29tbWFuZCIsImNsZWFuZWRDb21tYW5kIiwidG9Mb3dlckNhc2UiLCJ0cmltIiwid29yZHMiLCJzcGxpdCIsImZpcnN0V29yZCIsInF1YW50aXR5IiwibmFtZSIsInNsaWNlIiwiam9pbiIsImRpZ2l0TWF0Y2giLCJtYXRjaCIsInBhcnNlSW50IiwidXNlU2hvcHBpbmdMaXN0IiwiaXRlbXMiLCJzZXRJdGVtcyIsInNhdmVkSXRlbXNKU09OIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsInNhdmVkSXRlbXMiLCJKU09OIiwicGFyc2UiLCJtaWdyYXRlZEl0ZW1zIiwibWFwIiwiaXRlbSIsInByaWNlIiwiY29uc29sZSIsImxvZyIsImVycm9yIiwicmVtb3ZlSXRlbSIsInNldEl0ZW0iLCJzdHJpbmdpZnkiLCJhZGRJdGVtIiwiZXhpc3RpbmdJdGVtIiwiZmluZCIsImkiLCJpbmNyZWFzZVF1YW50aXR5IiwiaWQiLCJjYXRlZ29yeUtleSIsIk9iamVjdCIsImtleXMiLCJrZXkiLCJpbmNsdWRlcyIsIm5ld0l0ZW0iLCJEYXRlIiwibm93IiwidG9TdHJpbmciLCJjYXRlZ29yeSIsImFkZGVkQXQiLCJjb21wbGV0ZWQiLCJwcmV2IiwicmVtb3ZlSXRlbUJ5TmFtZSIsIml0ZW1FeGlzdHMiLCJzb21lIiwiZmlsdGVyIiwiYW1vdW50IiwiZGVjcmVhc2VRdWFudGl0eSIsIk1hdGgiLCJtYXgiLCJ0b2dnbGVJdGVtIiwiY2xlYXJMaXN0IiwiZ3JvdXBlZEl0ZW1zIiwicmVkdWNlIiwiZ3JvdXBzIiwicHVzaCIsInRvdGFsQ29zdCIsInRvdGFsIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/useShoppingList.ts\n"));

/***/ })

});